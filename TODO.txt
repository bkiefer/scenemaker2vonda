1. Javadoc vervollständigen
2. Code aufräumen: Vonda-Build aus chatcat-Ordner vervollständigen + lastDA().what-switch einfügen
3. Ggf. weitere Tests überlegen
5. Main.py "ersetzen"; Projekt als Shell-Script ausführbar machen (schöneres Handling von Kommandozeilenparametern!)
6. Konfigurationen als Kommandozeilenparameter oder Konfigurationsdatei? Umsetzen
7. Kurzanleitung: Wie baut man den Compiler, was ist im Hauptverzeichnis wo, wofür
8. ca. 2-4 Seiten Projektdokumentation: 
	- Welche Knoten / Kanten gibt es
	- Wie und wo kann man Variablen definieren, was ist der Scope?
	- Wie funktioniert die Übersetzung, so dass die Funktionalität des Automaten entsteht, z.B., wie funktioniert das "multi-process" Modell?
	- Was wird in der Ontologie wie dargestellt?
	- (Eventuell) Was muss man noch tun, um ein komplettes System zu erhalten (NICHT ASR/Interpretation/Generierung etc.), d.h.welche Teile fehlen, wenn man den 			Automaten kompiliert hat
	- Was fehlt oder sollte bald hinzugefügt werden?
	- Was könnte/sollte längerfristig hinzugefügt werden?


Anmerkungen und Dinge zum nochmal anschauen:


- Wir haben jetzt eine Methode, um sicherzustellen, dass Knotennamen immer LowerCase sind (ensureNodeNamesAreLowerCase in der Supernode-Klasse). Sollte das eine Option sein? Sollten wir in der Spezifikation erwähnen, dass Knotennamen klein geschrieben werden sollen?

- Hashtag-Lösung: Bisher Quickfix -> Kann/Soll der irgendwie raus? (Methode postProcessDialogueActs von RudiFileGenerator, wird benutzt in writeSupernodeToFile)

- Simple_interruptive_edges: Problem bei der bisherigen Lösung ist, dass imminent_simple_children jetzt keine Untermenge von simple_children mehr ist
