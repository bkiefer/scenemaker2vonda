Erstelle eine Datei "Functions.rudi". Definiere dort alle universellen Funktionen, d.h. schreibe Folgendes:


void set_inactive(Supernode m) {

	for (String x : m.simple_children) {removeTimeout(x);}
	for (Supernode y : m.super_children) {set_inactive(y);}
	
	m.active = false;
	m.simple_children = {};
	m.super_children = {};
	m.initiated = {};
}

boolean test_inactive(Supernode m) {
 
	return ((!m.super_children) && (!m.simple_children) && (!m.initiated));

}

void super_transition(String node_a, Supernode a_parent, String supernode_b) {

	cancelTimeout(node_a);

	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	a_parent.initiated += supernode_b;
}

void transition (String node_a, String node_b, Supernode a_parent, Supernode b_parent) {

	cancelTimeout(node_a);

	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	b_parent.simple_children += node_b;
}

void check_out_transition(String a, String b, Supernode a_parent, Supernode b_parent) {

	if (!hasActiveTimeout(a) && a_parent.simple_children.contains(a)) { 
	
		transition(a, b, a_parent, b_parent);
	}
}

void timeout_transition(String node_a, String node_b, Supernode a_parent, Supernode b_parent, int duration) {

	timeout(node_a, duration) {

		transition(node_a, node_b, a_parent, b_parent);
	}
}

void timeout_super_transition(String node_a, Supernode a_parent, String supernode_b, int duration) {

	timeout(node_a, duration) {

		super_transition(node_a, a_parent, supernode_b);
	}
}

void probability_transition(String node_a, String node_b, Supernode a_parent, Supernode b_parent) {

	propose_id = "propose_"+ node_a;
	
	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	propose(propose_id) {					
		transition(node_a, node_b, a_parent, b_parent);
	}
}

void probability_super_transition(String node_a, Supernode a_parent, String node_b) {

	propose_id = "propose_"+ node_a;
	
	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	propose(propose_id) {					
		super_transition(node_a, a_parent, node_b);
	}
}

void interruptive_transition(Supernode m, Supernode parent, String target_node) {
						
	set_inactive(m);	
	parent.simple_children += target_node;
}

void interruptive_super_transition(Supernode m, Supernode parent, String target_supernode) {
						
	set_inactive(m);	
	parent.initiated += target_supernode;
}



-----------------------------------------------------------------------------



Erstelle eine Datei "MainAgent.rudi" und für jeden Superknoten s eine Datei "S.rudi". Der Aufbau dieser Dateien ist wie folgt:

setup_s: // leicht anders in der MainAgent.rudi, siehe nächste Regel!
	if(PARENT-SUPERKNOTEN.initiated.contains("s") {
		if(!s.active) {
		
			s.active = true;
			PARENT-SUPERKNOTEN.super_children += s;

			FÜR JEDE VARIABLE v, DIE AN s DEFINIERT WIRD:
				s.v = DEFAULT-VALUE VON v;
		}
		
		s.simple_children += "s_in";
		PARENT-SUPERKNOTEN.initiated -= "s";
	}

setup_MainAgent: 
	if(!global.active) {
		timeout("globalStart", 1400) {
			global.active = true;
			s.simple_children += "s_in";

			FÜR JEDE VARIABLE v, DIE AN s DEFINIERT WIRD:
				s.v = DEFAULT-VALUE VON v;
		}
	}

pass_by_s:
	if(!s.active) {
		cancel;
	}

FÜR JEDE INTERRUPTIVE-EDGE (assoziiert mit Index i und mit Trigger-Condition c), DIE AUS s HINAUSFÜHRT:

	s_interruptive_edge_i:
		if (c) {
			WENN TARGET-KNOTEN IST SIMPLE_NODE: 
				interruptive_transition(s, PARENT-SUPERKNOTEN, TARGET-KNOTEN);
			SONST:
				interruptive_super_transition(s, PARENT-SUPERKNOTEN, TARGET-KNOTEN);

			cancel;
		}

s_in:
	if(s.simple_children.contains("s_in")) {
		
		CODE, DER IN SCENEMAKER DIREKT AM SUPERKNOTEN s STEHT;

		FÜR JEDEN NORMALEN STARTKNOTEN "m" von s:
			transition("s_in", "m", s, s);
		FÜR JEDEN SUPERKNOTEN t, DER STARTKNOTEN VON s IST:
			super_transition("s_in", s, "t"); 
		
		check_out_transition("s_in", "s_out", s, s);
	} 

s_out:
	if(s.simple_children.contains("s_out")) {
		
		FÜR JEDE (non-interruptive) EDGE e, DIE AUS DEM SUPERKNOTEN s HINAUSFÜHRT: CODE FÜR e (s. weiter unten)

		if(test_inactive(s)) {
			PARENT-SUPERKNOTEN.super_children -= s;
			set_inactive(s);
		}

		check_out_transition("s_out", "PARENT-SUPERKNOTEN_out", s, PARENT-SUPERKNOTEN);
	} 

FÜR JEDEN NORMALEN KNOTEN n IN s:
	n:
		if (s.simple_children.contains("n")) {
		
			if (!hasActiveTimeout("n")) {
				CODE, DER IN SCENEMAKER UNTER KNOTEN n STEHT;
			}

			FÜR JEDE EDGE e, DIE AUS n HINAUSFÜHRT: CODE FÜR e (s. weiter unten)

			check_out_transition("n", "s_out", s, s);

		}

FÜR JEDEN KIND-SUPERKNOTEN t VON s:
import T;




-----------------------------------------------------------------------------



Compile-Anweisung für Edge e:

Grundsätzlich -> Wenn node_a eine Supernode ist, dann sollte transition("node_a_out", ...) generiert werden! (Der Edge-Code landet dann im "_out"-Knoten der Supernode)


EPSILON-EDGE von node_a nach node_b:
	WENN node_b IST SIMPLE_NODE:
		transition("node_a", "node_b", parent_of_node_a, parent_of_node_b);
	SONST:
		super_transition("node_a", parent_of_node_a, "node_b");


FORK-EDGE von node_a nach node_1, ... , node_n:
	FÜR JEDEN KNOTEN node_b, ZU DEM EINE EDGE AUS node_a FÜHRT:
		WENN node_b IST SIMPLE_NODE:
			transition("node_a", "node_b", parent_of_node_a, parent_of_node_b);
		SONST:
			super_transition("node_a", "node_b", parent_of_node_a, parent_of_node_b);


TIME_OUT-EDGE von node_a nach node_b:
	WENN node_b IST SIMPLE_NODE:
		timeout_transition("node_a", "node_b", parent_of_node_a, parent_of_node_b, LENGTH_OF_TIME_OUT);
	SONST:
		timeout_super_transition("node_a", parent_of_node_a, "node_b", LENTH_OF_TIME_OUT);		

CONDITIONAL-EDGE von node_a nach node_b:
	if (CONDITION) {
		WENN node_b IST SIMPLE_NODE:
			transition("node_a", "node_b", parent_of_node_a, parent_of_node_b);
		SONST:
			super_transition("node_a", parent_of_node_a, "node_b");		
		}

PROBABILITY-EDGE von node_a nach node_1, ... , node_n:
	FÜR JEDEN KNOTEN node_b, ZU DEM EINE PROBABILITY-EDGE AUS node_a FÜHRT:
		WENN node_b IST SIMPLE_NODE:
			probability_transition("node_a", "node_b", parent_of_node_a, parent_of_node_b);	
		SONST:
			probability_super_transition("node_a", parent_of_node_a, "node_b");
-----------------------------------------------------------------------------



Compile-Anweisung für Code, der in Scenemaker unter den Knoten steht:

VARIABLEN AUFLÖSEN:
	- VARIABLE ERKENNEN
	- WENN VARIABLE LOKAL (IM AKTUELLEN SIMPLE_NODE) DEFINIERT:
		SCHREIBE VARIABLE-DEKLARATION UND EVENTUELL INITIALISIERUNG AN BEGINN DES CODE-ABSCHNITTS
	SONST WENN VARIABLE x IN SUPERKNOTEN supernode_a DEFINIERT IST:
		ERSETZE x DURCH supernode_a.x




