setup_main:
	if(!global.active) {
		
		timeout("globalStart", 1600) {		
			global.simple_children += "main_in";
			global.nice = 0;
			global.active = true;
		}
	}

void set_inactive(Supernode m) {

	for (String x : m.simple_children) {
		removeTimeout(x);
	}

	for (Supernode y : m.super_children) {
		set_inactive(y);
   	}
	
	m.active = false;
	m.simple_children = {};
	m.super_children = {};
	m.initiated = {};
	
}

boolean test_inactive(Supernode m) {
 
	return ((!m.super_children) && (!m.simple_children) && (!m.initiated));

}

void super_transition(String node_a, Supernode a_parent, String supernode_b) {

	cancelTimeout(node_a);

	// Im Falle von Fork Edges wird der Knoten ja vielleicht mehrfach "verlassen"
	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	a_parent.initiated += supernode_b;

}

void transition (String node_a, String node_b, Supernode a_parent, Supernode b_parent) {

	cancelTimeout(node_a);

	// Im Falle von Fork Edges wird der Knoten ja vielleicht mehrfach "verlassen", deshalb l√∂schen wir nur, wenn es das erste Mal ist
	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	b_parent.simple_children += node_b;

}

void check_out_transition(String node, String out_node, Supernode parent) {

	if (!hasActiveTimeout(node) && parent.simple_children.contains(node)) { 
	
		transition(node, out_node, parent, parent);
	}
}

void timeout_transition(String node_a, String node_b, Supernode a_parent, Supernode b_parent, int duration) {

	timeout(node_a, duration) {

		transition(node_a, node_b, a_parent, b_parent);
	}
}

void probability_transition(String node_a, String node_b, Supernode a_parent, Supernode b_parent) {

	propose_id = "propose_"+ node_a;
	
	if(a_parent.simple_children.contains(node_a)) {
		a_parent.simple_children -= node_a;
	}

	propose(propose_id) {					
		transition(node_a, node_b, a_parent, b_parent);
	}
}

void interruptive_transition(Supernode m, Supernode parent, String target_node) {
						
	set_inactive(m);	
	parent.simple_children += target_node;
}

void interruptive_super_transition(Supernode m, Supernode parent, String target_supernode) {
						
	set_inactive(m);	
	parent.initiated += target_supernode;
}

main_in_node:
	if(global.simple_children.contains("main_in")) {

		super_transition("main_in", global, "hello_node");
	} 

main_out_node:
	if(global.simple_children.contains("main_out")) {

		set_inactive(global);
		shutdown();
	}

excuse_node:
	if (global.simple_children.contains("excuse_node")) {
		
		emitDA(#InitialGoodbye(Leave));
		lastDAprocessed();

		transition("excuse_node", "bye_node", global, global);
	}

bye_node:
	if (global.simple_children.contains("bye_node")) {
	
		emitDA(#Valediction(Bye));
		lastDAprocessed();

		check_out_transition("bye_node", "main_out", global);
	}

import Hello_node;

