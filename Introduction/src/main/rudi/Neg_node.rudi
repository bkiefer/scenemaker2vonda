neg_node:
	Supernode this_node = ; //TODO: Datenbankanfrage(Superknoten mit Label "neg_node")
	if (this_node.oneChildActive()) {
		// Interruptive Edges:
		if (req_mood == true) {
			for (String x : this_node.states) {
				states.remove(x);
				removeTimeout(x);
			}
			for (Supernode x : this_node.superchildren) {
				x.remove_states() // l√∂scht auch deren Timeouts
			}
			states.add("answer_node");
			
		} else {
			neg_node_in:
				if (states.contains("neg_node_in")) {
					transition("neg_node_in", "no_node");
				}

			neg_node_out:
				if (states.contains("neg_node_out")) {
					transition("neg_node_out", "excuse_node");					
				}

				// Gestrichelte Kante hier nicht notwendig, da Kante aus neg_node raus eine Epsilon-Kante ist

			no_node:
				if (states.contains("no_node")) {

					emitDA(#Connecting(NegativeFeeling));

					probability_transition("no_node", "joke_node");	
					probability_transition("no_node", "sorry_node");	
					probability_transition("no_node", "happy_node");					
				}

			joke_node:
				if (states.contains("joke_node")) {

					emitDA(#Encouragement(Joke));

					check_out_transition("joke_node", "neg_node_out");
				}

			sorry_node:
				if (states.contains("sorry_node")) {

					emitDA(#Connecting(Sorry));

					check_out_transition("sorry_node", "neg_node_out");
				}

			happy_node:
				if (states.contains("happy_node")) {

					emitDA(#Encouragement(Tomorrow));
					
					check_out_transition("happy_node", "neg_node_out");
				}
		}
	}

