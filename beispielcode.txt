# TODO vars initialisieren (aber wie?)
# Superknoten-Objekte erstellen
states = {"hello_node_in"} # Globaler Startknoten --> Rekursiv
import("hello_node") # hello_nodes Superknoten werden rekursiv importiert

if "bye_node" in states:
  emitDA("Bye")
  exit()

-------------------
|hello_node module|
-------------------
import("pos_node")
import("neg_node")

if this.oneChildActive():
  # Interruptive edges
  if bye == true:
    for x in this.states:
      states.remove(x)
      cancelTimeout(x)
    for x in this.superchildren:
      x.remove_states() # löscht auch deren Timeouts
    states.add("bye_node")

  else:
    # Knoten in hello_node
      # hello_node_in (Pseudo-Startknoten)
      if "hello_node_in" in states:
        if true:
          states.remove("hello_node_in")
          states.add("hi_node")

      # hello_node_out (Pseudo-Endknoten)
      if "hello_node_out" in states:
        states.remove("hello_node_out")
        states.add("bye_node")
      # Gestrichelte Kante hier nicht notwendig, da die nächsthöhere Ebene Toplevel ist

      # hi_node
      if "hi_node" in states:
        emitDA("hi")

        if true:
          timeout("hi_node", 5000) {
              states.remove("hi_node")
              states.add("how_node")
          }

        if hello == true:
          cancelTimeout("hi_node")
          states.remove("hi_node")
          states.add("how_node")

        if no_timeout("hi_node") and "hi_node" in states:
          states.add("hello_node_out")
          states.remove("hi_node")

      # how_node
      if "how_node" in states:
        emitDA("How are you?")

        if mood == -1:
          cancelTimeout("how_node")
          states.remove("how_node")
          states.add("neg_node")

        if mood == 1:
          cancelTimeout("how_node")
          states.remove("how_node")
          states.add("pos_node")

        if no_timeout("how_node") and "hi_node" in states:
          states.add("hello_node_out")
          states.remove("how_node")

      # answer_node
      if "anwser_node" in states:
        emitDA("I'm fine, thanks")

        if true:
          states.remove("anwser_node")
          states.add("excuse_node")

        if no_timeout("answer_node") and "hi_node" in states:
          states.add("hello_node_out")
          states.remove("answer_node")

      # excuse_node
      if "excuse_node" in states:
        emitDA("I have to go now")

        if no_timeout("excuse_node") and "hi_node" in states:
          states.add("hello_node_out")
          states.remove("excuse_node")

-----------------
|pos_node module|
-----------------
if this.oneChildActive():

  # Interruptive Edges:
  if req_mood == true:
    for x in this.states:
      states.remove(x)
      cancelTimeout(x)
    for x in this.superchildren:
      x.remove_states() # löscht auch deren Timeouts
    states.add("answer_node")

  else:
    # pos_node_in
    if "pos_node_in" in states:
      if true:
        states.remove("pos_node_in")
        states.add("cool_node")

    # pos_node_out
    if "pos_node_out" in states:
      if true:
        states.remove("pos_node_out")
        states.add("excuse_node")
    # Gestrichelte Kante hier nicht notwendig, da Edge aus pos_node raus eine Epsilon-Kante ist

    # cool_node
    if "cool_node" in states:
      emitDA("Cool")

      if true:
        states.remove("cool_node")
        states.add("why_node")

      if no_timeout("cool_node") and "cool_node" in states:
        states.remove("cool_node")
        states.add("pos_node_out")

    # why node
    if "why_node" in states:
      emitDA("Why are you so happy today?")

      if true:
        timeout("why_node", 10000) {
          states.remove("why_node")
          states.add("great_node")
        }

      if no_timeout("why_node") and "cool_node" in states:
        states.remove("why_node")
        states.add("pos_node_out")

    # great_node
    if "great_node" in states:
      emitDA("That's great")
      states.remove("great_node")

      if no_timeout("great_node") and "cool_node" in states:
        states.remove("great_node")
        states.add("pos_node_out")

-----------------
|neg_node module|
-----------------
if this.oneChildActive():

  # Interruptive Edges:
  if req_mood == true:
    for x in this.states:
      states.remove(x)
      cancelTimeout(x)
    for x in this.superchildren:
      x.remove_states() # löscht auch deren Timeouts
    states.add("answer_node")
  else:
    #neg_node_in
    if "neg_node_in" in states:
      if true:
        states.remove("neg_node_in")
        states.add("no_node")

    #neg_node_out
    if "neg_node_out" in states:
      if true:
        states.remove("neg_node_out")
        states.add("excuse_node")
    # Gestrichelte Kante hier nicht notwendig, da Kante aus neg_node raus eine Epsilon-Kante ist

    # no_node
    if "no_node" in states:
      emitDA("Oh no!")
      states.remove("no_node")

      propose {states.add("joke_node")}
      propose {states.add("sorry_node")}
      propose {states.add("happy_node")}

      #TODO Verhalten bei Propose-Node? --> Wann zu out-Node gehen?

    # joke_node
    if "joke_node" in states:
      emitDA("joke")
      states.remove("joke_node")

      if no_timeout("joke_node") and "joke_node" in states:
        states.remove("joke_node")
        states.add("neg_node_out")

    # sorry_node
    if "sorry_node" in states:
      emitDA("I'm so sorry")
      states.remove("sorry_node")

      if no_timeout("sorry_node") and "sorry_node" in states:
        states.remove("sorry_node")
        states.add("neg_node_out")

    # happy_node
    if "happy_node" in states:
      emitDA("Tomorrow will be a happy day again")
      states.remove("happy_node")

      if no_timeout("happy_node") and "happy_node" in states:
        states.remove("happy_node")
        states.add("neg_node_out")
