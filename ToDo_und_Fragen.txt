
- Nochmal darüber nachdenken, ob man ohne eine "super_"-Transition für jede Kantenart auskommen kann -> Falls ja, dann VonDa- und CompilerCode ändern! (etwas nervig im Moment)
Aktuelles Problem mit den super_transitions: Es sollte auch 4 Argumente (statt 3) haben, da man ggf. von einem Pseudo-out-Knoten in einen Superknoten EINE EBENE WEITER OBEN wechseln muss -> Dann bräuchte man noch das parent-Superknoten-Objekt
	-> So, wie ich es gerade umbaue (Boolean in transition, die sagt, ob der Target eine Supernode ist), muss ich noch testen ob boolean/true/false in VonDa alle kleingeschrieben werden!

- Testen, ob unsere Lösung mit den "imminent_simple_children" funktioniert -> Zunächst auf jeden Fall die ntGenerierung daran anpassen!

- Wir haben jetzt eine Methode, um sicherzustellen, dass Knotennamen immer LowerCase sind. Ist das gut so? Und funktioniert es, wie es soll?

- Wird in Vonda ein Timeout neu angelegt, wenn schon ein Timeout mit dem gleichen Namen existiert? Falls ja, sollten wir unsere timeout_transition so umschreiben, dass der Timeout nur angelegt wird, falls noch kein Timeout dieses Namens vorhanden ist

- Den Pfad zum Output-Ordner für die rudi-Dateien und die Ontologie-Datei sowie die uri könnte man dem Compiler auch als args mitgeben (-> Oder ist es sogar besser, das statisch zu machen?)

- JavaDoc anlegen

- Parser so umbauen, dass Nodes sich ihre ausgehenden Kanten separat nach Art der Kante merken? Das würde das iterieren über alle timeout-, Probability- bzw. Conditional-Edges leichter machen. Oder würde etwas anderes schwieriger dadurch?

- Nochmal schauen: Wieso klappt es nicht, alle Funktionen in ein separates "Functions.rudi"-File auszulagern und dieses dann als erstes in "MainAgent.rudi" zu importieren? Zuletzt kompilierte er dann nicht. Inzwischen stecken die Funktionen einfach am Anfang der "MainAgent.rudi"

------------------

Ggf. nicht mehr nötig:

	- Parser: Member (Object.attribute.something usw...) parsen können
	- Hashtag-Lösung: Bisher Quickfix -> Kann/Soll der irgendwie raus? (Methode postProcessDialogueActs von RudiFileGenerator, wird benutzt in writeSupernodeToFile)

------------------

Was muss man noch machen nach dem Kompilieren?

	- Im compile-Skript den Namen der Main-Klasse (MainAgent.rudi) einstellen
	- Im Ontology-Ordner in der Datei "introduction.ini" den Default-Namespace ("cat =") an die uri aus ontology.nt anpassen
	- In der Java-Datei "ChatAgent" alle Supernode-Objekte einmal als Variablen definieren (oben) und in der init-Methode die Variablen mit dem entsprechenden Datenbankobjekt verknüpfen
	- In der Java-Datei "StubClient" das Attribut "_agent" als Instanz der Klasse "MainAgent" deklarieren und in der init-Methode die Zeile "_agent = new MainAgent()" hinzufügen

	Obiges ist in "Compiled_Introduction" schon geschehen, Folgendes muss aber jedes Mal neu gemacht werden:

		- rudi-Dateien und ontology.nt-file in den richtigen Ordner verschieben (dabei ontology.nt zu introduction.nt umbenennen)
		- In der rudi-Datei "Hello_node" an der wait_node noch das ".what" nach lastDA() ergänzen  
		- Sicherstellen, dass der target Ordner und der src/main/gen-java Unterordner gelöscht sind, bevor neu kompiliert wird!
		- Den gesamten Ordner nach vonda/examples verschieben (und dort "./compile", "mvn install" und "./openGUI" ausführen)

-------

Notizen 31.7.

Zwischen"zustand" einführen, der codiert, ob man an einem Knoten den Code schon einmal ausgeführt hat oder nicht -> Nützlich, um Spammen von Code zu verhindern 
	-> Nach dieser Änderung: Probability-Edges-Code umändern, so dass der Start-Knoten noch nicht rausgeworfen wird, bevor Proposals geniert werden [löst das Problem von oben]
